import { NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabaseClient';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const TABLE = 'event';
const FIELDS = '*';

function nilIfEmpty(x: unknown) {
  if (x === undefined || x === null) return null;
  const s = String(x).trim();
  return s === '' ? null : s;
}
function mapRow(r: any) {
  if (!r) return null;
  return {
    EventID: r.eventid ?? r.event_id ?? r.id ?? r.EventID ?? null,
    Title: r.title ?? 'Untitled Event',
    Description: r.description ?? null,
    Venue: r.venue ?? null,

    StartDateTime: r.startdatetime ?? null,
    EndDateTime: r.enddatetime ?? null,

    Fee: typeof r.fee === 'number' ? r.fee : (r.fee == null ? null : Number(r.fee)),
    BankName: r.bankname ?? null,
    BankAccountNo: r.bankaccountno ?? null,
    BankAccountName: r.bankaccountname ?? null,
    PromptPayQR: r.promptpayqr ?? null,

    OrganizerName: r.organizername ?? null,
    OrganizerLineID: r.organizerlineid ?? null,
    LineGpURL: r.linegpurl ?? null,
    LineGpQRCode: r.linegpqrcode ?? null,
    ScholarshipHours: r.scholarshiphours ?? null,

    MaxParticipant: r.maxparticipant ?? null,
    ParticipantDeadline: r.participantdeadline ?? null,
    MaxStaff: r.maxstaff ?? null,
    MaxStaffDeadline: r.maxstaffdeadline ?? null,

    SAU_ID: r.sau_id ?? null,
    AUSO_ID: r.auso_id ?? null,
    Status: r.status ?? null,

    PosterURL: null,
  };
}

// POST /api/events  (create)
export async function POST(req: Request) {
  try {
    const body = await req.json();

    const insert: Record<string, any> = {
      title: nilIfEmpty(body.Title) ?? 'Untitled Event',
      description: nilIfEmpty(body.Description),
      venue: nilIfEmpty(body.Venue ?? body.Location),

      startdatetime: body.StartDateTime ?? body.StartDate ?? null,
      enddatetime: body.EndDateTime ?? body.EndDate ?? null,

      fee: body.Fee == null ? null : Number(body.Fee),
      bankname: nilIfEmpty(body.BankName),
      bankaccountno: nilIfEmpty(body.BankAccountNo),
      bankaccountname: nilIfEmpty(body.BankAccountName),
      promptpayqr: nilIfEmpty(body.PromptPayQR),

      organizername: nilIfEmpty(body.OrganizerName),
      organizerlineid: nilIfEmpty(body.OrganizerLineID),
      linegpurl: nilIfEmpty(body.LineGpURL),
      linegpqrcode: nilIfEmpty(body.LineGpQRCode),
      scholarshiphours: body.ScholarshipHours == null ? null : Math.trunc(Number(body.ScholarshipHours)),

      maxparticipant: body.MaxParticipant ?? null,
      participantdeadline: nilIfEmpty(body.ParticipantDeadline),
      maxstaff: body.MaxStaff ?? null,
      maxstaffdeadline: nilIfEmpty(body.MaxStaffDeadline),

      status: (() => {
        const up = String(body.Status ?? 'PENDING').toUpperCase();
        return up === 'APPROVED' ? 'LIVE' : up;
      })(),

      sau_id: body.SAU_ID ?? null,
      auso_id: body.AUSO_ID ?? null,
    };

    const s = insert.startdatetime ? new Date(insert.startdatetime) : null;
    const e = insert.enddatetime ? new Date(insert.enddatetime) : null;
    if (s && e && (isNaN(s.getTime()) || isNaN(e.getTime()) || e <= s)) {
      return NextResponse.json({ error: 'EndDate must be after StartDate.' }, { status: 400 });
    }
    if (s && insert.participantdeadline) {
      const pd = new Date(insert.participantdeadline);
      if (!isNaN(pd.getTime()) && pd > s) {
        return NextResponse.json(
          { error: 'ParticipantDeadline must be on/before StartDateTime.' },
          { status: 400 }
        );
      }
    }
    if (s && insert.maxstaffdeadline) {
      const sd = new Date(insert.maxstaffdeadline);
      if (!isNaN(sd.getTime()) && sd > s) {
        return NextResponse.json(
          { error: 'MaxStaffDeadline must be on/before StartDateTime.' },
          { status: 400 }
        );
      }
    }

    const supabase = getSupabaseServer();
    const { data, error } = await supabase
      .from(TABLE)
      .insert(insert)
      .select(FIELDS)
      .single();

    if (error || !data) {
      return NextResponse.json({ error: error?.message || 'Insert failed' }, { status: 400 });
    }

    return NextResponse.json(mapRow(data), { status: 201 });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}

// GET /api/events  (list)
export async function GET(req: Request) {
  try {
    const supabase = getSupabaseServer();
    const { searchParams } = new URL(req.url);
    const statusParam = searchParams.get('status');
    const limitParam = searchParams.get('limit');

    let query = supabase.from(TABLE).select(FIELDS);
    if (statusParam) {
      const statuses = statusParam.split(',').map((s) => s.trim()).filter(Boolean);
      if (statuses.length === 1) query = query.eq('status', statuses[0]);
      else if (statuses.length > 1) query = query.in('status', statuses);
    }

    const limit = limitParam ? Math.max(1, Math.min(1000, Number(limitParam))) : null;
    if (limit) query = query.limit(limit);

    query = query.order('startdatetime', { ascending: false }).order('eventid', { ascending: false });

    const { data, error } = await query;
    if (error) return NextResponse.json({ error: error.message }, { status: 400 });

    const items = Array.isArray(data) ? data.map(mapRow) : [];
    return NextResponse.json(items);
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}

import { NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabaseClient';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const TABLE = 'event';
const FIELDS =
  'eventid, title, description, venue, startdatetime, enddatetime, status, fee, posterurl, photourl, photo_url, organizername';

function mapRow(r: any) {
  if (!r) return null;
  return {
    EventID: r.eventid ?? r.id ?? null,
    Title: r.title ?? 'Untitled Event',
    Description: r.description ?? null,
    Venue: r.venue ?? null,
    StartDateTime: r.startdatetime ?? null,
    EndDateTime: r.enddatetime ?? null,
    Status: (r.status ?? 'PENDING') as string,
    Fee: r.fee ?? null,
    PhotoURL: r.photo_url ?? r.photourl ?? r.posterurl ?? null,
    OrganizerName: r.organizername ?? null,
  };
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const status = (url.searchParams.get('status') || '').trim().toUpperCase();
    const q = (url.searchParams.get('q') || '').trim();

    const supabase = getSupabaseServer();
    let query = supabase.from(TABLE).select(FIELDS, { count: 'exact' });

    if (status && status !== 'ALL') {
      query = query.eq('status', status);
    }

    if (q) {
      query = query.or(
        [
          `title.ilike.%${q}%`,
          `description.ilike.%${q}%`,
          `venue.ilike.%${q}%`,
          `organizername.ilike.%${q}%`,
        ].join(',')
      );
    }

    query = query.order('startdatetime', { ascending: true }).order('eventid', { ascending: false });

    const { data, error } = await query;
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    const items = (Array.isArray(data) ? data : []).map(mapRow).filter(Boolean);
    return NextResponse.json({ items, count: items.length });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}

